// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// GetOldBookingsForUserHandlerFunc turns a function with the right signature into a get old bookings for user handler
type GetOldBookingsForUserHandlerFunc func(GetOldBookingsForUserParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn GetOldBookingsForUserHandlerFunc) Handle(params GetOldBookingsForUserParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// GetOldBookingsForUserHandler interface for that can handle valid get old bookings for user params
type GetOldBookingsForUserHandler interface {
	Handle(GetOldBookingsForUserParams, interface{}) middleware.Responder
}

// NewGetOldBookingsForUser creates a new http.Handler for the get old bookings for user operation
func NewGetOldBookingsForUser(ctx *middleware.Context, handler GetOldBookingsForUserHandler) *GetOldBookingsForUser {
	return &GetOldBookingsForUser{Context: ctx, Handler: handler}
}

/* GetOldBookingsForUser swagger:route GET /users/{user_name}/oldbookings users getOldBookingsForUser

Get all old bookings for the user

Get all old bookings for the user. It's assumed that no pagination will be required due to likely policy limits including usage limits and users typically having only a couple of policies, although in practice pagination may be useful for heavy users.

*/
type GetOldBookingsForUser struct {
	Context *middleware.Context
	Handler GetOldBookingsForUserHandler
}

func (o *GetOldBookingsForUser) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetOldBookingsForUserParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc.(interface{}) // this is really a interface{}, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
