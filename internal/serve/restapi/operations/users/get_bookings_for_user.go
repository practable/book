// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// GetBookingsForUserHandlerFunc turns a function with the right signature into a get bookings for user handler
type GetBookingsForUserHandlerFunc func(GetBookingsForUserParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn GetBookingsForUserHandlerFunc) Handle(params GetBookingsForUserParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// GetBookingsForUserHandler interface for that can handle valid get bookings for user params
type GetBookingsForUserHandler interface {
	Handle(GetBookingsForUserParams, interface{}) middleware.Responder
}

// NewGetBookingsForUser creates a new http.Handler for the get bookings for user operation
func NewGetBookingsForUser(ctx *middleware.Context, handler GetBookingsForUserHandler) *GetBookingsForUser {
	return &GetBookingsForUser{Context: ctx, Handler: handler}
}

/*
	GetBookingsForUser swagger:route GET /users/{user_name}/bookings users getBookingsForUser

# Get all current bookings for the user

Get all current bookings for the user. It's assumed that no pagination will be required due to likely policy limits being a couple of bookings per policy and users typically having only a couple of policies. No pagination may cause issues for admins that book hundreds or thousands slots on behalf of students, although it is likely such bookings would be automated so no need to support rapid update of a GUI, at least for now.
*/
type GetBookingsForUser struct {
	Context *middleware.Context
	Handler GetBookingsForUserHandler
}

func (o *GetBookingsForUser) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetBookingsForUserParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc.(interface{}) // this is really a interface{}, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
