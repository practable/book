// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// CancelBookingHandlerFunc turns a function with the right signature into a cancel booking handler
type CancelBookingHandlerFunc func(CancelBookingParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn CancelBookingHandlerFunc) Handle(params CancelBookingParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// CancelBookingHandler interface for that can handle valid cancel booking params
type CancelBookingHandler interface {
	Handle(CancelBookingParams, interface{}) middleware.Responder
}

// NewCancelBooking creates a new http.Handler for the cancel booking operation
func NewCancelBooking(ctx *middleware.Context, handler CancelBookingHandler) *CancelBooking {
	return &CancelBooking{Context: ctx, Handler: handler}
}

/* CancelBooking swagger:route DELETE /users/{user_name}/bookings/{booking_name} users bookings cancelBooking

Cancel the booking

For users to cancel their booking(s) on at a time. Checks if the booking is unstarted and/or unfulfilled, and cancels if so. A booking cannot be cancelled once an activity has been requested. A booking can be cancelled after it started, so long as it is unfulfilled (no activity requested). The user must be the owner of the booking to cancel it. Admins can cancel bookings by Lock() -> ExportBookings() -> edit -> ReplaceBookings()-> Unlock(). There is no need for an endpoint for admin single booking cancellation because the only visibility they have of bookings is via ExportBookings. Remaing time in the booking at time of cancellation is refunded to the user's usage tracker for that policy. That is intended to encourage early cancellation. Returns 404 on successful cancellation, or if there is no such booking.

*/
type CancelBooking struct {
	Context *middleware.Context
	Handler CancelBookingHandler
}

func (o *CancelBooking) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewCancelBookingParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc.(interface{}) // this is really a interface{}, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
