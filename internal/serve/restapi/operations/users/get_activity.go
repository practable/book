// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// GetActivityHandlerFunc turns a function with the right signature into a get activity handler
type GetActivityHandlerFunc func(GetActivityParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn GetActivityHandlerFunc) Handle(params GetActivityParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// GetActivityHandler interface for that can handle valid get activity params
type GetActivityHandler interface {
	Handle(GetActivityParams, interface{}) middleware.Responder
}

// NewGetActivity creates a new http.Handler for the get activity operation
func NewGetActivity(ctx *middleware.Context, handler GetActivityHandler) *GetActivity {
	return &GetActivity{Context: ctx, Handler: handler}
}

/* GetActivity swagger:route PUT /users/{user_name}/bookings/{booking_name} users bookings getActivity

Request the activity that goes with the booking

Checks if the booking has started or not and if so, returns an activity that can be used to access the booked resource. Since this mutates the state of the booking (from unfulfilled to fulfilled) it is a put not a get.

*/
type GetActivity struct {
	Context *middleware.Context
	Handler GetActivityHandler
}

func (o *GetActivity) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetActivityParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc.(interface{}) // this is really a interface{}, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
