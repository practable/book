// Code generated by go-swagger; DO NOT EDIT.

package users

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new users API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for users API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AddPolicyForUser(params *AddPolicyForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddPolicyForUserNoContent, error)

	CancelBooking(params *CancelBookingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	GetAccessToken(params *GetAccessTokenParams, opts ...ClientOption) (*GetAccessTokenOK, error)

	GetActivity(params *GetActivityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetActivityOK, error)

	GetAvailability(params *GetAvailabilityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAvailabilityOK, error)

	GetBookingsForUser(params *GetBookingsForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBookingsForUserOK, error)

	GetDescription(params *GetDescriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDescriptionOK, error)

	GetOldBookingsForUser(params *GetOldBookingsForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetOldBookingsForUserOK, error)

	GetPoliciesForUser(params *GetPoliciesForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPoliciesForUserOK, error)

	GetPolicy(params *GetPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPolicyOK, error)

	GetPolicyStatusForUser(params *GetPolicyStatusForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPolicyStatusForUserOK, error)

	MakeBooking(params *MakeBookingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MakeBookingNoContent, error)

	GetStoreStatusUser(params *GetStoreStatusUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetStoreStatusUserOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AddPolicyForUser adds policy to user account

  Add policy to the list of policies with which this user is allowed to make bookings
*/
func (a *Client) AddPolicyForUser(params *AddPolicyForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddPolicyForUserNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddPolicyForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddPolicyForUser",
		Method:             "POST",
		PathPattern:        "/users/{user_name}/policies/{policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AddPolicyForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddPolicyForUserNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AddPolicyForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CancelBooking cancels the booking

  For users to cancel their booking(s) on at a time. Checks if the booking is unstarted and/or unfulfilled, and cancels if so. A booking cannot be cancelled once an activity has been requested. A booking can be cancelled after it started, so long as it is unfulfilled (no activity requested). The user must be the owner of the booking to cancel it. Admins can cancel bookings by Lock() -> ExportBookings() -> edit -> ReplaceBookings()-> Unlock(). There is no need for an endpoint for admin single booking cancellation because the only visibility they have of bookings is via ExportBookings. Remaing time in the booking at time of cancellation is refunded to the user's usage tracker for that policy. That is intended to encourage early cancellation. Returns 404 on successful cancellation, or if there is no such booking.
*/
func (a *Client) CancelBooking(params *CancelBookingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelBookingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CancelBooking",
		Method:             "DELETE",
		PathPattern:        "/users/{user_name}/bookings/{booking_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CancelBookingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
  GetAccessToken requests a user access token

  The access token is required to authenticate requests to the rest of the user-facing API. Ideally access to this endpoint should be secured by the identity management system. The access token has a limited lifetime but can be re-requested as needed. Consider rate-limiting this per-connection.
*/
func (a *Client) GetAccessToken(params *GetAccessTokenParams, opts ...ClientOption) (*GetAccessTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAccessTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAccessToken",
		Method:             "POST",
		PathPattern:        "/login/{user_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAccessTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAccessTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAccessToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetActivity requests the activity that goes with the booking

  Checks if the booking has started or not and if so, returns an activity that can be used to access the booked resource. Since this mutates the state of the booking (from unfulfilled to fulfilled) it is a put not a get.
*/
func (a *Client) GetActivity(params *GetActivityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetActivityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetActivity",
		Method:             "PUT",
		PathPattern:        "/users/{user_name}/bookings/{booking_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetActivityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetActivityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetActivity: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAvailability gets availability for the slot under the policy

  Pagination is supported by the limit and offset parameters. For the first query '?limit=20&offset=0', the second '?limit=20&offset=20'. The offset is equal to the zero-indexed value of the first item of the next page to be returned (20 items are indexed from 0 to 19, so 20 is the first item to be returned in the second page). Note that drift can occur if slots are booked during the sending of availability data, potentially preventing a user from seeing some slots that move earlier in the index and cross a pagination boundary. Users should refresh their results from 0 offset on a regular-ish basis if they wish to avoid this.
*/
func (a *Client) GetAvailability(params *GetAvailabilityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAvailabilityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAvailabilityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAvailability",
		Method:             "GET",
		PathPattern:        "/policies/{policy_name}/slots/{slot_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAvailabilityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAvailabilityOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAvailability: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetBookingsForUser gets all current bookings for the user

  Get all current bookings for the user. It's assumed that no pagination will be required due to likely policy limits being a couple of bookings per policy and users typically having only a couple of policies. No pagination may cause issues for admins that book hundreds or thousands slots on behalf of students, although it is likely such bookings would be automated so no need to support rapid update of a GUI, at least for now.
*/
func (a *Client) GetBookingsForUser(params *GetBookingsForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBookingsForUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBookingsForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetBookingsForUser",
		Method:             "GET",
		PathPattern:        "/users/{user_name}/bookings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBookingsForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetBookingsForUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetBookingsForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetDescription gets description

  Get description
*/
func (a *Client) GetDescription(params *GetDescriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDescriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDescriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetDescription",
		Method:             "GET",
		PathPattern:        "/descriptions/{description_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDescriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDescriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetDescription: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetOldBookingsForUser gets all old bookings for the user

  Get all old bookings for the user. It's assumed that no pagination will be required due to likely policy limits including usage limits and users typically having only a couple of policies, although in practice pagination may be useful for heavy users.
*/
func (a *Client) GetOldBookingsForUser(params *GetOldBookingsForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetOldBookingsForUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOldBookingsForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetOldBookingsForUser",
		Method:             "GET",
		PathPattern:        "/users/{user_name}/oldbookings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetOldBookingsForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetOldBookingsForUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetOldBookingsForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetPoliciesForUser gets all current policies for user

  Get all current policies for user
*/
func (a *Client) GetPoliciesForUser(params *GetPoliciesForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPoliciesForUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPoliciesForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetPoliciesForUser",
		Method:             "GET",
		PathPattern:        "/users/{user_name}/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPoliciesForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPoliciesForUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetPoliciesForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetPolicy gets policy

  Get policy
*/
func (a *Client) GetPolicy(params *GetPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetPolicy",
		Method:             "GET",
		PathPattern:        "/policies/{policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetPolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetPolicyStatusForUser gets policy status

  Get policy status for the user
*/
func (a *Client) GetPolicyStatusForUser(params *GetPolicyStatusForUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetPolicyStatusForUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPolicyStatusForUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetPolicyStatusForUser",
		Method:             "GET",
		PathPattern:        "/users/{user_name}/policies/{policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPolicyStatusForUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPolicyStatusForUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetPolicyStatusForUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  MakeBooking requests a booking

  A booking is requested for a specific combination of policy-slot-user-from-to. Users should check availability first, and only make requests that are likely to be granted. If there is no current availability then requests will be denied. If there is availability, there is still a chance another user requests the same slot just before - whichever request is received by the server first will be allowed, the other denied. The user_name must match the user_name the user logged in with, that is in the authorisation token in the header.
*/
func (a *Client) MakeBooking(params *MakeBookingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MakeBookingNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMakeBookingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MakeBooking",
		Method:             "POST",
		PathPattern:        "/policies/{policy_name}/slots/{slot_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &MakeBookingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MakeBookingNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for MakeBooking: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetStoreStatusUser gets current store status

  Gets the current store status from a user perspective (e.g. is it locked? what is the reason?)
*/
func (a *Client) GetStoreStatusUser(params *GetStoreStatusUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetStoreStatusUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetStoreStatusUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getStoreStatusUser",
		Method:             "GET",
		PathPattern:        "/users/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetStoreStatusUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetStoreStatusUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getStoreStatusUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
